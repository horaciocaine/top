a:37:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1;}i:3;a:3:{i:0;s:12:"section_edit";i:1;a:4:{i:0;i:-1;i:1;i:0;i:2;i:1;i:3;s:0:"";}i:2;i:1;}i:4;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"Running SMTP Commands using Swift";i:1;i:1;i:2;i:1;}i:2;i:1;}i:5;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:48;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"
Swift is based around the ";}i:2;i:49;}i:8;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"SMTP";}i:2;i:76;}i:9;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:" protocol.  Even the NativeMail connection has been written to speak ";}i:2;i:80;}i:10;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"SMTP";}i:2;i:149;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:" to Swift.  For this reason, it probably won't surprise you that there are mechanisms in place for running ";}i:2;i:153;}i:12;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"SMTP";}i:2;i:260;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:" commands through Swift yourself.";}i:2;i:264;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:297;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:297;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"The Swift::command() method returns a ResponseEvent object which holds information about the ";}i:2;i:299;}i:17;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"SMTP";}i:2;i:392;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" response from the server.";}i:2;i:396;}i:19;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:422;}i:20;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:422;}i:21;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:196:"If you just want to run a command and read the response, you simply need to pass the command string to command(), leaving off the trailing CRLF (line ending) and then check what's in the response.";}i:2;i:424;}i:22;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:620;}i:23;a:3:{i:0;s:4:"code";i:1;a:2:{i:0;s:158:"
$response =& $swift->command("HELO");
//Check the full response
echo $response->getString();
//Check the response code (e.g. 250)
echo $response->getCode();
";i:1;s:3:"php";}i:2;i:627;}i:24;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:797;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"It's often critical that a ";}i:2;i:799;}i:26;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"SMTP";}i:2;i:826;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:102:" response adheres to something you expect, otherwise you may need to issue a reset() command (RSET in ";}i:2;i:830;}i:28;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"SMTP";}i:2;i:932;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:249:").  You can either check the response yourself from getCode() as shown above, or you can assert that an error should be thrown if a bad response is received.  This is more useful in PHP5 where exceptions are used, since excpetions are easily caught.";}i:2;i:936;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1185;}i:31;a:3:{i:0;s:4:"code";i:1;a:2:{i:0;s:92:"
//Throw an error if 250 is not the response code
$response = $swift->command("HELO", 250);
";i:1;s:3:"php";}i:2;i:1192;}i:32;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1296;}i:33;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"The exception used if the response is bad, is of type Swift_Connection_Exception.";}i:2;i:1298;}i:34;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1379;}i:35;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1380;}i:36;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:1380;}}