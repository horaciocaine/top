<?xml version="1.0" encoding="utf-8"?>
<!-- generator="FeedCreator 1.7.2-ppt DokuWiki" -->
<?xml-stylesheet href="http://swiftmailer.org/wikidocs/lib/exe/css.php?s=feed" type="text/css"?>
<rdf:RDF
    xmlns="http://purl.org/rss/1.0/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel rdf:about="http://swiftmailer.org/wikidocs/feed.php">
        <title>SwiftMailer Docs v3</title>
        <description></description>
        <link>http://swiftmailer.org/wikidocs/</link>
        <image rdf:resource="http://swiftmailer.org/wikidocs/lib/images/favicon.ico" />
       <dc:date>2009-04-13T08:04:55+00:00</dc:date>
        <items>
            <rdf:Seq>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/attachments?rev=1172337563&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/basic?rev=1171479116&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/batch?rev=1171784105&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/bounce_address?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/contents?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/embedding_images?rev=1173265512&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/exceptions?rev=1171479176&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/extracting?rev=1171583499&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/failed_recipients?rev=1171481557&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/faq_parseerror?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/faq_unittests?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/form2mail?rev=1173709141&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/html?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/message_attachments?rev=1171479065&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/message_priority?rev=1171481832&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/misc_caching?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/misc_commands?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/misc_php4errors?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/multipart?rev=1171458349&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/multipart_detail?rev=1172336876&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/multirecipients?rev=1171450165&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugin_antiflood?rev=1171482062&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugin_bandwidthmonitor?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugin_decorator?rev=1206526940&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugin_manipulating?rev=1171482021&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugin_throttler?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugin_verbose?rev=1174510700&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_beforecommandevent?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_beforesendevent?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_commandevent?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_connectevent?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_disconnectevent?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_intro?rev=1171575971&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_responseevent?rev=1236058881&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugindev_sendevent?rev=1171575299&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/plugins_loading?rev=1171481868&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/read_receipts?rev=1171481653&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/recipients?rev=1171448980&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/sending_basics?rev=1171481302&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/sending_batch?rev=1171481485&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/sending_multiple?rev=1171481391&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/smtpauth?rev=1179869903&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/start?rev=1190361270&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_connection_multi?rev=1171467003&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_connection_nativemail?rev=1171479898&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_connection_rotator?rev=1171467632&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_connection_sendmail?rev=1171452718&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_connection_smtp?rev=1171479790&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_message?rev=1171474473&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_message_headers?rev=1171480864&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/swift_message_image?rev=1171481052&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/testing?rev=1173264018&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/tips_memory?rev=1172337419&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/tips_spam?rev=1171540378&amp;do=diff"/>
                <rdf:li rdf:resource="http://swiftmailer.org/wikidocs/v3/uploading?rev=1171583530&amp;do=diff"/>
            </rdf:Seq>
        </items>
    </channel>
    <image rdf:about="http://swiftmailer.org/wikidocs/lib/images/favicon.ico">
        <title>SwiftMailer Docs</title>
        <link>http://swiftmailer.org/wikidocs/</link>
        <url>http://swiftmailer.org/wikidocs/lib/images/favicon.ico</url>
    </image>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/attachments?rev=1172337563&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-24T17:19:23+00:00</dc:date>
        <title>Sending attachments</title>
        <link>http://swiftmailer.org/wikidocs/v3/attachments?rev=1172337563&amp;do=diff</link>
        <description>Luckily, attachments are much like MIME parts in a multipart message, expect they are not displayed by default and are encoded in a special way.  You attach files to an email using the attach() method in swift like you do when you add MIME parts, but you use the Swift_Message_Attachment class rather than the Swift_Message_Part class.  Swift then includes the message as an attachment, rather than a textual part of the email.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/basic?rev=1171479116&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T18:51:56+00:00</dc:date>
        <title>Sending a basic email</title>
        <link>http://swiftmailer.org/wikidocs/v3/basic?rev=1171479116&amp;do=diff</link>
        <description>Sending an email with Swift Mailer is a simple process.  You basically create a new instance of Swift with a connection type of your choice, you then create a message and ask Swift to deliver it to one or more recipients.  Perhaps if you're not familiar with OOP this snippet may look a little daunting but it should hopefully soon become familiar to you and feel quite natural.  EasySwift, packaged inside the library when you download it, provides a wrapper which makes this even simpler - at the e…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/batch?rev=1171784105&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-18T07:35:05+00:00</dc:date>
        <title>Sending a batch email</title>
        <link>http://swiftmailer.org/wikidocs/v3/batch?rev=1171784105&amp;do=diff</link>
        <description>If you try to deliver an email to more than one recipient by using the Swift_RecipientList class in combination with Swift's send() method, you need to be aware that all the recipients of the message will be able to see each other's addresses in their mail clients.  This is fine for social/work emails, but if you were sending something like a newsletter or a marketing campaign it wouldn't look great and could even land you in trouble for breach of data protection.  To avoid any such problems, yo…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/bounce_address?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Setting the Bounce detect, or Return-path address</title>
        <link>http://swiftmailer.org/wikidocs/v3/bounce_address?rev=1236058881&amp;do=diff</link>
        <description>When using SMTP, you don't always know if the message is going to reach the recipient.  If something goes wrong and you're really lucky you'll know about it at SMTP time if the server reports an error; if you're not so lucky, but not completely in the dark, you'll receive an email from a different server saying that something went wrong; and if you're completely unlucky, you'll just be left wondering why you never got a response from the recipient.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/contents?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Swift Version 3 Documentation</title>
        <link>http://swiftmailer.org/wikidocs/v3/contents?rev=1236058881&amp;do=diff</link>
        <description>Swift Version 3 Documentation</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/embedding_images?rev=1173265512&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-03-07T11:05:12+00:00</dc:date>
        <title>Embedding images in HTML E-mails</title>
        <link>http://swiftmailer.org/wikidocs/v3/embedding_images?rev=1173265512&amp;do=diff</link>
        <description>Once you have learned how to add attachments to an email with Swift, and how to send HTML emails with Swift, this will probably make sense.  Using HTML it's easy to add an &lt;img .. /&gt; tag to the message and link it to a remote image on your web server.  However, you can attach the image and link to the attachment directly.  This has it benefits, as well as its drawbacks (bandwidth!).  Many mail clients now block remote images by default, so embedding images could mean that your image is more like…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/exceptions?rev=1171479176&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T18:52:56+00:00</dc:date>
        <title>Catching useful errors</title>
        <link>http://swiftmailer.org/wikidocs/v3/exceptions?rev=1171479176&amp;do=diff</link>
        <description>THIS PAGE APPLIES TO PHP5 ONLY


Swift Mailer version 3 throws exceptions in PHP5.  These exceptions should ideally be caught so that you can recover from them if required.  It's not compulsory to catch exceptions but it is good practice and it does help.  The API documentation packaged in the “docs” folder indicates where exceptions are thrown.  The only time this should happen in practise, is if your mail server is not configured correctly or is unavailable, or if you try doing something illeg…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/extracting?rev=1171583499&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-15T23:51:39+00:00</dc:date>
        <title>Extracting the archive</title>
        <link>http://swiftmailer.org/wikidocs/v3/extracting?rev=1171583499&amp;do=diff</link>
        <description>Downloads of Swift Mailer come in two different archive formats.  There's a tarball (the one with .tar.gz) or a ZIP file (the one with .zip).  Both archives contain exactly the same files so it's up to you which one you download.

Extracting the archives on Linux or Mac OS X


Tarball:</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/failed_recipients?rev=1171481557&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:32:37+00:00</dc:date>
        <title>Dealing with failed recipients</title>
        <link>http://swiftmailer.org/wikidocs/v3/failed_recipients?rev=1171481557&amp;do=diff</link>
        <description>SMTP does occassionally reject recipient addresses due to malformity, domain conflicts, DNS issues and other problems.  If you want to track who got rejected you should enable Swift's logging facility so that these failures can be collected.  The failed addresses will be stored in $swift-&gt;log-&gt;getFailedRecipients() as an array.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/faq_parseerror?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Are you getting Parse Errors?</title>
        <link>http://swiftmailer.org/wikidocs/v3/faq_parseerror?rev=1236058881&amp;do=diff</link>
        <description>If you are getting parse errors upon including Swift Mailer in your code, it's almost definitely because you have downloaded the wrong version.  There are two releases of Swift.  One is for PHP4 and the other is for PHP5.  If you try using the PHP5 version in PHP4 you WILL get parse errors.  Make sure you are using the appropriate version.  The filenames all have the PHP version they were made for in them.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/faq_unittests?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>The Unit Tests are using too much Memory</title>
        <link>http://swiftmailer.org/wikidocs/v3/faq_unittests?rev=1236058881&amp;do=diff</link>
        <description>If you run the group tests, and you're unlucky you may be getting one of the following:


	*  A blank page
	*  Asked to download the php file
	*  A memory exhaustion error


This is due to the fact that the group tests are examining a lot of areas of Swift and in the process need to do things such as regexp over strings and create mock objects (dummy objects which act like the real thing).  This takes it toll on memory.  The tests have been split into 4 separate groups and the highest memory use…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/form2mail?rev=1173709141&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-03-12T14:19:01+00:00</dc:date>
        <title>Sending an e-mail from a form with Swift</title>
        <link>http://swiftmailer.org/wikidocs/v3/form2mail?rev=1173709141&amp;do=diff</link>
        <description>Ok, so Swift isn't going to write the form and handle user input for you.  I'll assume you already know how to deal with forms in PHP.  If you don't, you might want to read here first: &lt;http://www.w3schools.com/php/php_forms.asp&gt;.  The only thing Swift will do is create the email for you and send it.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/html?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Sending a HTML E-Mail</title>
        <link>http://swiftmailer.org/wikidocs/v3/html?rev=1236058881&amp;do=diff</link>
        <description>Sending a HTML email with Swift is just as easy as sending a plain-text email.  You just need to tell the Message that's it's in HTML format and everything else is the same as if you were sending plain-text.  HTML has it's advantages in that it's easy to create a layout with images and styles, but not all mail clients will read it, and if you're not careful, you might be increasing the risk of being blocked as spam.  See How to (legitimately) minimize being seen as spam.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/message_attachments?rev=1171479065&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T18:51:05+00:00</dc:date>
        <title>Dealing with Attachments</title>
        <link>http://swiftmailer.org/wikidocs/v3/message_attachments?rev=1171479065&amp;do=diff</link>
        <description>Synopsis: new Swift_Message_Attachment([mixed data [, string filename [, string content-type [, string encoding [, string disposition]]]]])

An attachment yet again, another MIME document.  It's special because it contains any format of data such as a PDF, a Zip file or an executable.  In order for SMTP to proccess such data it gets encoded into a format which looks like plain-text (such as Base64).</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/message_priority?rev=1171481832&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:37:12+00:00</dc:date>
        <title>Changing the message priority</title>
        <link>http://swiftmailer.org/wikidocs/v3/message_priority?rev=1171481832&amp;do=diff</link>
        <description>The message priority does little more than flag the message in the recipients INBOX as being important or not.  To set the priority, you make a change to the message itself.  You can provide an integer ranging from 1 (High) to 5 (Low) to indicate the priority.  By default, no priority is indicated which equates to a priority of 3 (Normal).  The class constants used in the example below map to the relevant integer values of the priority.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/misc_caching?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Swift's Runtime Cache</title>
        <link>http://swiftmailer.org/wikidocs/v3/misc_caching?rev=1236058881&amp;do=diff</link>
        <description>Swift Mailer incorporates a runtime cache to help speed things up a lot.  Composing emails is a tough business.  You need to encode files, correct line endings, translate to formats laid out in the RFCs.  It's therefore easier if you can just do this once and once it's been done, re-use the results.  Swift caches various pieces of data (computed strings) on various different levels whilst it composes messages.  This is all handled by an abstracted caching layer.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/misc_commands?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Running SMTP Commands using Swift</title>
        <link>http://swiftmailer.org/wikidocs/v3/misc_commands?rev=1236058881&amp;do=diff</link>
        <description>Swift is based around the SMTP protocol.  Even the NativeMail connection has been written to speak SMTP to Swift.  For this reason, it probably won't surprise you that there are mechanisms in place for running SMTP commands through Swift yourself.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/misc_php4errors?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>PHP4 error handling - The alternative to exceptions</title>
        <link>http://swiftmailer.org/wikidocs/v3/misc_php4errors?rev=1236058881&amp;do=diff</link>
        <description>In PHP5, Swift throws exceptions in places, which is fairly standard practise.  Exceptions of course, can be caught and dealt with.  PHP4 however, does not support exceptions (the use of the try/catch construct).  I could have triggered errors everywhere blindly and had you use set_error_handler() from PHP, but that's too intrusive and can easily conflict with other things happening in your application.  Instead, Swift dispatches error object, much like an exception from PHP5, to an error manage…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/multipart?rev=1171458349&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T13:05:49+00:00</dc:date>
        <title>Sending a multipart email</title>
        <link>http://swiftmailer.org/wikidocs/v3/multipart?rev=1171458349&amp;do=diff</link>
        <description>When you use a mail client such as Thunderbird to send an email in both HTML and Plain-text you are asking it to send a multipart message.  This uses a standard called MIME.  The essence of what's actually being sent is that rather than just sending one body of text and one set of headers, the email contains a main set of headers which identify it as having more than one part, and the body is replaced with two smaller documents, each with their own headers and bodies.  The mail client then decid…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/multipart_detail?rev=1172336876&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-24T17:07:56+00:00</dc:date>
        <title>Multi-Part Messages in Detail</title>
        <link>http://swiftmailer.org/wikidocs/v3/multipart_detail?rev=1172336876&amp;do=diff</link>
        <description>A potentially confusing preamble


Hopefully, I won't confuse people here... if I do, just ignore this entire rambling and go straight to the bottom of the page... It's not important, it's just useful to think about.

If we imagine representing an email as XML we'd have a document which looks something like this:</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/multirecipients?rev=1171450165&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T10:49:25+00:00</dc:date>
        <title>Sending to multiple recipients</title>
        <link>http://swiftmailer.org/wikidocs/v3/multirecipients?rev=1171450165&amp;do=diff</link>
        <description>In the previous tutorials you may have read, we've been providing recipient addresses using a string, or using the Swift_Address class.  However, Swift can send to Bcc recipients, Cc recipients and multiple To recipients.  For this, we use the Swift_RecipientList class.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugin_antiflood?rev=1171482062&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:41:02+00:00</dc:date>
        <title>Using the AntiFlood plugin</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugin_antiflood?rev=1171482062&amp;do=diff</link>
        <description>Synopsis: new Swift_Plugin_AntiFlood([int threshold [, int pause]])

The AntiFlood plugin is designed to help lessen the load on the HTTP server and the SMTP server.  It can also be used to send out very large batches of emails when the SMTP server has restrictions in place to limit the number of emails sent in one go.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugin_bandwidthmonitor?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Swift Bandwidth Monitoring/Tracking Plugin</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugin_bandwidthmonitor?rev=1236058881&amp;do=diff</link>
        <description>Depending upon what you're doing, or shoud I say, the scale of what you're sending you may wish to keep track of how much bandwidth Swift is using.  This plugin measures the incoming and outgoing bandwidth through the connection.

NOTE: The figures are from Swift's point of view, not the server.  “Bytes in” refers to bytes from the SMTP server back into swift; “bytes out” refers to bytes sent from Swift to the SMTP server.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugin_decorator?rev=1206526940&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2008-03-26T10:22:20+00:00</dc:date>
        <title>Swift Message Decorator Plugin (For Customized Messages)</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugin_decorator?rev=1206526940&amp;do=diff</link>
        <description>Introduction to message decorating


Swift Mailer uses a caching system which operates on small units of the e-mail you compose.  If something's already been encoded/rendered and you try to encode/render it again swift reads the cache.  This offers a huge performance boost when sending the same message to many recipients.  Even once the message has been cached, you can change items such as the subject, body or transfer-encoding and Swift will use most of the message from the cache and re-render …</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugin_manipulating?rev=1171482021&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:40:21+00:00</dc:date>
        <title>Working with plugins after loading</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugin_manipulating?rev=1171482021&amp;do=diff</link>
        <description>Plugins are held inside Swift by-reference and you can get a reference to that plugin yourself by using the getPlugin() method.  When you load a plugin into Swift you need to give it a name.  You use that name to retreive a reference to it.  This comes in particularly useful when you want to run methods in a plugin at runtime.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugin_throttler?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Throttler Plugin to restrict the speed</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugin_throttler?rev=1236058881&amp;do=diff</link>
        <description>If you want to run a batch send that's going to take a long time and don't want to hog the server's resources and/or bandwidth in the process perhaps this plugin is the solution.  Unlike the AntiFlood plugin, which offers a similar solution, the throttler works on the basis of restricting speed, not on the basis of minimizing the number of emails per-connection.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugin_verbose?rev=1174510700&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-03-21T20:58:20+00:00</dc:date>
        <title>Verbose Sending Plugin (Debug-use only)</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugin_verbose?rev=1174510700&amp;do=diff</link>
        <description>The verbose sending plugin dumps out green and red bars during the sending of batches in order to allow you to quickly identify recipients who are not going through the SMTP connection.  It's unlikely you'll need to use this plugin for anything other than debugging.  Usage is simple, all you have to do is load it into Swift along with the View class it uses (or one of your own).</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_beforecommandevent?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>How to use BeforeCommandListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_beforecommandevent?rev=1236058881&amp;do=diff</link>
        <description>A plugin which implements the Swift_Events_BeforeCommandListener interface will be invoked every time Swift is about to issue an SMTP command.  The plugin will have access to the command being executed and any changes made to the command inside the plugin will be executed at the time when the command would normally execute.  Plugins which implement either the CommandListener or BeforeCommandListener are most likely listening for those event by means of tracking the progress of sending an email r…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_beforesendevent?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>How to use BeforeSendListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_beforesendevent?rev=1236058881&amp;do=diff</link>
        <description>The two event listeners in Swift which are likely to be the most heavily implemented are SendListener and BeforeSendListener.  BeforeSendListener is run before the message gets sent.  You will know who the recipients are and what the message is at this stage, but Swift will not yet have sent the message so you can change recipients and/or modify the message and then it will be sent.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_commandevent?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>How to use CommandListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_commandevent?rev=1236058881&amp;do=diff</link>
        <description>A plugin which implements the Swift_Events_CommandListener interface will be invoked whenever Swift has sent a command.  The CommandEvent object which is passed is the same object as the one a plugin implementing BeforeCommandListener would have already seen.  Therefore, any changes made before the command is issued will be also seen here after the command has been issued.  More often than not, BeforeCommandListener will be more useful than CommandListener.  We could use something like this to m…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_connectevent?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Writing a ConnectListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_connectevent?rev=1236058881&amp;do=diff</link>
        <description>As the name suggests, a ConnectListener will be notified every time Swift connects to the SMTP server or other MTA.  A plugin which implements the Swift_Events_ConnectListener interface will be passed an instance of Swift_Events_ConnectEvent when a connection is established.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_disconnectevent?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>Writing a DisconnectListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_disconnectevent?rev=1236058881&amp;do=diff</link>
        <description>A DisconnectListener will be notified every time Swift disconnects from the SMTP server or local MTA.  A plugin which implements the Swift_Events_DisconnectListener interface will be passed an instance of Swift_Events_DisconnectEvent when a disconnection occurs.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_intro?rev=1171575971&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-15T21:46:11+00:00</dc:date>
        <title>An introduction to Swift's Plugin API</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_intro?rev=1171575971&amp;do=diff</link>
        <description>Swift has come a leap forward from it's version 2 days where learning to use the plugin system was a confusing business unless you knew Swift's core inside-out.  In Version 3, things are clearer and simpler.  The entire basis of the plugin system is centered around the concept of event-driven programming.  Observers (Event Listeners) are plugged into Swift's core class.  Swift then dispatches Events (as objects) to these event listeners.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_responseevent?rev=1236058881&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2009-03-03T05:41:21+00:00</dc:date>
        <title>How to use ResponseListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_responseevent?rev=1236058881&amp;do=diff</link>
        <description>A plugin which implements Swift_Events_ResponseListener will be invoked every time Swift receives a new response from the connection.  This can come in useful if used in combination with a CommandListener because if you know what response codes to expect, you can “correct” problems by issuing the RSET command or whatever other action may be appropriate.  It probably helps to know a little about the SMTP protocol before attempting such things however.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugindev_sendevent?rev=1171575299&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-15T21:34:59+00:00</dc:date>
        <title>How to use SendListener</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugindev_sendevent?rev=1171575299&amp;do=diff</link>
        <description>A plugin which implements the Swift_Events_SendListener interface will be invoked every time Swift has sent a message to a recipient.  The event passed is of type Swift_Events_SendEvent, just like the BeforeSendListener.  In fact, the event you get passed is actually a reference to that same event you would have already seen if your plugin implements BeforeSendListener!  So if you're plugin implements both SendListener and BeforeSendListener, you could change the SendEvent before the message is …</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/plugins_loading?rev=1171481868&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:37:48+00:00</dc:date>
        <title>Loading new plugins into Swift</title>
        <link>http://swiftmailer.org/wikidocs/v3/plugins_loading?rev=1171481868&amp;do=diff</link>
        <description>Plugins in Swift are nothing more than event listeners (a sort of observer).  If you download a plugin, or want to load one of the packaged ones you first need to include the file in your script using the “include” or “require” keywords.  You then use the attachPlugin() method in Swift to pass an instance of the plugin to Swift.  Swift quite simply sends messages (events) to the plugin at relevent times.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/read_receipts?rev=1171481653&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:34:13+00:00</dc:date>
        <title>Requesting a Read-Receipt</title>
        <link>http://swiftmailer.org/wikidocs/v3/read_receipts?rev=1171481653&amp;do=diff</link>
        <description>Read-Receipts are not very reliable since most emails clients will either prompt, or block them.  However, if you do desire to request a read-receipt you should set this in the message itself, before sending:


$message =&amp; new Swift_Message(&quot;My subject&quot;, &quot;My body&quot;);
$message-&gt;requestReadReceipt(&quot;your@address.tld&quot;);</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/recipients?rev=1171448980&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T10:29:40+00:00</dc:date>
        <title>Personalizing recipient names</title>
        <link>http://swiftmailer.org/wikidocs/v3/recipients?rev=1171448980&amp;do=diff</link>
        <description>When you send an email with Swift you can just provide the address as a string.  However, if you want to send a personal name along with the address you will need to use the Swift_Address class*.  This class is simply making life easier for Swift to ensure addresses are given in the correct format when used in message headers and when sent to the SMTP server.  It's extremely basic and simply takes one or two arguments in the constructor.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/sending_basics?rev=1171481302&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:28:22+00:00</dc:date>
        <title>Sending a message to a recipient</title>
        <link>http://swiftmailer.org/wikidocs/v3/sending_basics?rev=1171481302&amp;do=diff</link>
        <description>Sending messages in Swift is extremely simple.  You call the send() method, which only has 3 parameters.  One is the message, one is the recipient, and the other is the sender.


$swift =&amp; new Swift(new Swift_Connection_SMTP(&quot;host.tld&quot;));

$message =&amp; new Swift_Message(&quot;My subject&quot;, &quot;My body&quot;);

$sent = $swift-&gt;send($message, &quot;recipient@address.tld&quot;, &quot;sender@address.tld&quot;);
echo &quot;Sent to $sent recipients&quot;;</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/sending_batch?rev=1171481485&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:31:25+00:00</dc:date>
        <title>Sending a batch email or newsletter</title>
        <link>http://swiftmailer.org/wikidocs/v3/sending_batch?rev=1171481485&amp;do=diff</link>
        <description>We you send out an email marketing campaign, newsletter or any other type of batch email you don't particularly want to reveal everybody's address to the recipients.  One nasty hack is to Bcc all the recipients and leave the To: field undisclosed.  However, Swift provides a method specially for the purpose of sending out batch emails.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/sending_multiple?rev=1171481391&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:29:51+00:00</dc:date>
        <title>Sending to mulitple recipients</title>
        <link>http://swiftmailer.org/wikidocs/v3/sending_multiple?rev=1171481391&amp;do=diff</link>
        <description>Sending to multiple recipients, or including Cc and Bcc recipients is handled by passing an instance of Swift_RecipientList as the recipient parameter in send().

Swift_RecipientList() contains the methods addTo(), addCc() and addBcc() along with removeTo(), removeCc() etc.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/smtpauth?rev=1179869903&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-05-22T21:38:23+00:00</dc:date>
        <title>SMTP Authentication</title>
        <link>http://swiftmailer.org/wikidocs/v3/smtpauth?rev=1179869903&amp;do=diff</link>
        <description>The SMTP connection in Swift provides a mechanism to use SMTP authentication against a remote server.  You use the setUsername() and setPassword() methods of the Swift_Connection_SMTP class to acheive this:


$smtp =&amp; new Swift_Connection_SMTP(&quot;smtp.host.tld&quot;);
$smtp-&gt;setUsername(&quot;foo&quot;);
$smtp-&gt;setPassword(&quot;bar&quot;);</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/start?rev=1190361270&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-09-21T07:54:30+00:00</dc:date>
        <title>Swift Mailer 3</title>
        <link>http://swiftmailer.org/wikidocs/v3/start?rev=1190361270&amp;do=diff</link>
        <description>Swift Mailer 3


Version 3 is the latest release.  It offers many beneficial changes over Version 2.

Library API Reference

	*  PHP4 API Documentation
	*  PHP5 API Documentation

Tutorials

	*  Sending a basic email
	*  Sending a HTML email
	*  Sending a multipart email
	*  Personalizing recipient names
	*  Catching useful errors
	*  Sending attachments
	*  Embedding images in HTML emails
	*  Sending to multiple recipients and/or copying to recipients
	*  Sending a batch email without revealing…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_connection_multi?rev=1171467003&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T15:30:03+00:00</dc:date>
        <title>Swift_Connection_Multi</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_connection_multi?rev=1171467003&amp;do=diff</link>
        <description>Synopsis: new Swift_Connection_Multi( [array connections] )

The Multi connection is a mechanism which contains within itself any number of connections you give it.  These connections can be of any combination of types (SMTP, Sendmail, NativeMail, other instances of Multi etc etc).  It's a way of providing redundancy in the event that a SMTP server is unavailable at the time of the request for example.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_connection_nativemail?rev=1171479898&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:04:58+00:00</dc:date>
        <title>Swift_Connection_NativeMail</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_connection_nativemail?rev=1171479898&amp;do=diff</link>
        <description>Synopsis: new Swift_Connection_NativeMail( void )

This is probably the simplest of all the connections to get to grips with.  It uses PHP's mail() function.  It takes no constructor parameters and requires no configuration.

NOTE: Due to differences between mail() in Windows and mail() on UNIX-like systems there will be small inconsistencies between running this connection on Windows and Linux/OS X.  These are perfectly fine.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_connection_rotator?rev=1171467632&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T15:40:32+00:00</dc:date>
        <title>Swift_Connection_Rotator</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_connection_rotator?rev=1171467632&amp;do=diff</link>
        <description>Synopsis: new Swift_Connection_Rotator( [array connections] )

Much like the Multi connection, the Rotator connection also provides redundancy.  However, in addition it also provides a fairly unintelligent way to load balance between connections.

You provide it with a collection of different connections (possibly including some other rotating ones if you're crazy enough to do so ;)) and it tries each one in turn until one works, the rest are marked as “dead” internally and will not be retried. …</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_connection_sendmail?rev=1171452718&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T11:31:58+00:00</dc:date>
        <title>Swift_Connection_Sendmail</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_connection_sendmail?rev=1171452718&amp;do=diff</link>
        <description>Synopsis: new Swift_Connection_Sendmail([string command])

Sendmail is a binary executable which runs on UNIX-like systems such as Linux and OS X.  The Swift_Connection_Sendmail class runs this executable in a standalone SMTP mode and sends emails through it.  If you have sendmail available to you this will be much faster than using the SMTP connection to a remote server, however, it does have one drawback - load balancing.  If you use sendmail then your server is processing Swift instructions, …</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_connection_smtp?rev=1171479790&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:03:10+00:00</dc:date>
        <title>Swift_Connection_SMTP</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_connection_smtp?rev=1171479790&amp;do=diff</link>
        <description>Synopsis: new Swift_Connection_SMTP(string remote_host[, int remote_port [, int encryption_level]])

Getting connected to SMTP


The SMTP connection is probably the most heavily used connection, and almost certainly the most consistent and portable.  This connection opens up a socket with TCP and speaks “SMTP” to a remote SMTP server.  You need to have a SMTP server which is capable of relaying mail from the domain of your web server for this to work.  Some hosts provide a SMTP server for you as…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_message?rev=1171474473&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T17:34:33+00:00</dc:date>
        <title>Basics of Swift_Message</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_message?rev=1171474473&amp;do=diff</link>
        <description>Synopsis: new Swift_Message([string subject [, mixed body [, string content-type [, string encoding [, string charset ]]]]])

Unlike other email libraries, Swift is fully Object-oriented.  Message composition could be bundled into the main Swift class by all means... but it's not.  The EasySwift class does that if you really want it.  Swift itself doesn't do anything to do with the creation of emails.  Instead, there's a subset of classes included to allow you to do that.  All of these classes s…</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_message_headers?rev=1171480864&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:21:04+00:00</dc:date>
        <title>Manipulating MIME Headers</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_message_headers?rev=1171480864&amp;do=diff</link>
        <description>Setting and getting headers


Each component of a message contains a headers property which is an instance of Swift_Message_Headers.  Such components include Swift_Message, Swift_Message_Part and Swift_Message_Attachment.

The headers contain vital information about the structure of that component.  Each component will have a different set of headers depending upon what the component does.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/swift_message_image?rev=1171481052&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-14T19:24:12+00:00</dc:date>
        <title>Embedding images</title>
        <link>http://swiftmailer.org/wikidocs/v3/swift_message_image?rev=1171481052&amp;do=diff</link>
        <description>When you send a HTML format email you can of course include the &lt;img /&gt; tag.  Commonly, people will do something like:

&lt;img src=&quot;http://your-host.tld/images/foo.png&quot; alt=&quot;foo&quot; /&gt;

However, because this links to a remote image you may find that your recipient does not see the image as the mail client may block remote images by default.  If you'd prefer to send the image as part of the email you need to embed it.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/testing?rev=1173264018&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-03-07T10:40:18+00:00</dc:date>
        <title>Running the included tests</title>
        <link>http://swiftmailer.org/wikidocs/v3/testing?rev=1173264018&amp;do=diff</link>
        <description>Swift comes with a complete set of tests just to ensure everything works the way it's expect to.  There are three types of tests included with the library: Smoke Tests, Unit Tests and Benchmarks.  All of these are found in the “tests” directory.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/tips_memory?rev=1172337419&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-24T17:16:59+00:00</dc:date>
        <title>Keep memory down to a minimum</title>
        <link>http://swiftmailer.org/wikidocs/v3/tips_memory?rev=1172337419&amp;do=diff</link>
        <description>If you're sending out a large batch of emails (in the thousands of recipients) you probably need to think slightly more about your approach to delivering the emails.  In general, if you can send two emails in a loop using X amount of memory, you should only need a negligible amount more memory to send out ten thousand.  Obviously you need more time too!</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/tips_spam?rev=1171540378&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-15T11:52:58+00:00</dc:date>
        <title>How to (legitimately) minimize being seen as spam</title>
        <link>http://swiftmailer.org/wikidocs/v3/tips_spam?rev=1171540378&amp;do=diff</link>
        <description>This is a BIG topic and seemingly one that many people are quite patchy on.  I'll try to give you enough knowledge to make your own judgements and what you could do to minimize your risk.  You may finish up sad and disappointed by the end of this article though so don't build your hopes up that there's a quick-fix solution if you are being blocked as spam.</description>
    </item>
    <item rdf:about="http://swiftmailer.org/wikidocs/v3/uploading?rev=1171583530&amp;do=diff">
        <dc:format>text/html</dc:format>
        <dc:date>2007-02-15T23:52:10+00:00</dc:date>
        <title>Uploading to the server</title>
        <link>http://swiftmailer.org/wikidocs/v3/uploading?rev=1171583530&amp;do=diff</link>
        <description>Once the archive has been extracted you will have a new directory named something like
Swift-&lt;version&gt;

Inside this directory there are several files and folders.  You should read the README and INSTALL files before you do anything else.


  w3style:~/public_html/Swift-3.0-rc1 d11wtq$ ls -l
  total 80
  -rw-r--r--   1 d11wtq  d11wtq   1976 Dec 28 21:00 CHANGES
  -rw-r--r--   1 d11wtq  d11wtq   1351 Dec 28 21:00 INSTALL
  -rw-r--r--   1 d11wtq  d11wtq  24382 Dec 28 21:00 LICENSE
  -rw-r--r--   1 …</description>
    </item>
</rdf:RDF>
