====== How to use SendListener ======

A plugin which implements the Swift_Events_SendListener interface will be invoked every time Swift has sent a message to a recipient.  The event passed is of type Swift_Events_SendEvent, just like the BeforeSendListener.  In fact, the event you get passed is actually a reference to that same event you would have already seen if your plugin implements BeforeSendListener!  So if you're plugin implements both SendListener and BeforeSendListener, you could change the SendEvent before the message is sent and still see those changes after the message was sent.

Here's the interface:

<code php>
/**
 * Contains the list of methods a plugin requiring the use of a SendEvent must implement
 * @package Swift_Events
 * @author Chris Corbyn <chris@w3style.co.uk>
 */
interface Swift_Events_SendListener extends Swift_Events_Listener
{
	/**
	 * Executes when Swift sends a message
	 * @param Swift_Events_SendEvent Information about the message being sent
	 */
	public function sendPerformed(Swift_Events_SendEvent $e);
}
</code>

Let's do something semi-useful and write a plugin which sends an email report to you after an email has been sent.  It will tell you who the recipients were and how many recipients were rejected.  The obvious concern here is that we will be calling Swift's send() method from a SendListener which means we risk a never ending recursion if we don't think about what we're doing!

The SendEvent object contains methods for getRecipients(), getMessage() and getSender() -- as with **all** Swift events it also contains getSwift() so you can work with the instance of Swift which triggered the event.

Here's an example of the plugin which sends you a report.

<code php>
class SwiftReportGeneratorPlugin implements Swift_Events_SendListener
{
    protected $address;
    protected $message;
    
    public function __construct($your_address)
    {
        $this->setAddress($your_address);
        $this->setMessage(new Swift_Message("Swift Mailer Report"));
    }

    public function setMessage(Swift_Message $message)
    {
        $this->message = $message;
    }

    public function getMessage()
    {
        return $this->message;
    }

    public function setAddress(Swift_Address $address)
    {
        $this->address = $address;
    }
    
    public function getAddress()
    {
        return $this->address;
    }

    public function getTemplate()
    {
        return <<<TEMPLATE
This message is a report generated by the report generator plugin in Swift.

A message was sent to the following recipients on {date}:

{recipients}

Of the above recipients, {num_sent} were accpeted for delivery.

A copy of the message source is shown below:

---------
{source}
---------

TEMPLATE;
    }

    public function sendPerformed(Swift_Events_SendEvent $e)
    {
        //make sure we're not generating a report for our own message
        if ($e->getMessage() === $this->getMessage()) return;
        
        $num_sent = $e->getNumSent();
        $message = $e->getMessage();
        $date = date("r", $message->getDate());
        $source = $message->build();
        $recipient_str = "";
        $recipients = $e->getRecipients();
        //The keys are the addresses
        $to = array_keys($recipients->getTo());
        $recipient_str .= "Recipients in the To: field:\r\n" .
            implode(",\r\n", $to) . "\r\n";
        $cc = array_keys($recipients->getCc());
        $recipient_str .= "Recipients in the Cc: field:\r\n" .
            implode(",\r\n", $cc) . "\r\n";
        $bcc = array_keys($recipients->getBcc());
        $recipient_str .= "Recipients in the Bcc: field:\r\n" .
            implode(",\r\n", $bcc) . "\r\n";
        
        $report = $this->getMessage();
        $report->setBody(
            str_replace(array("{date}", "{recipients}", "{num_sent}", "{source}"),
            array($date, $recipient_str, $num_sent, $source), $this->getTemplate()));
        
        $swift = $e->getSwift();
        $swift->send($report, $this->getAddress(), "reporter@domain.tld");
    }
}
</code>

Although it's long(ish) it should be logical.  Writing plugins never gets much twistier than this :)